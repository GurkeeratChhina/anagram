import time

primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
raw_input = 'google_10000_english.txt'
processed_input = 'google_10000_english_dict.txt'

# Encodes letters as prime numbers
# Example usage: letter_to_prime("e") = 11
def letter_to_prime(letter):
    index = ord(letter) - ord('a')
    return primes[index]

# Each word gets assigned a number such that two words have the same number iff they have all the same letters
# Example usage: word_to_number("hello") = 19*11*37*37*47 = 13447687
def word_to_number(word):
    product = 1
    for letter in word:
        product = product * letter_to_prime(letter)
    return product

# Given a list of strings, find a list of possible sentences from anagramming each string
# Example usage: search_strings(["a", "aber", "aet", "em"]) = 
# [["a"], ["bear", "bare"], ["ate", "eta", "tea"], ["me"]]
def search_strings(list_of_strings, english_dict):
    list_of_sentences = []
    for string in list_of_strings:
        key = word_to_number(string)
        try:
            values = english_dict[key]
            list_of_sentences.append(values)
        except:
            return []
    return list_of_sentences

# A substring is a list of strings, named such because the list of strings add up to a given string
# Given a list of substrings, generate a new list of substrings where each new substring has length 1 less than the input
# The new substrings are generated by concatenating each pair of words in a given substring
# The output should have no duplicate substrings, where two substrings with a different order are considered duplicates 
# eg ["a", "b"] and ["b", "a"] are considered duplicate substrings
# Example usage: concatenate_strings([["abc", "def", "gh"], ["ijk", "lm", "nop"]]) =
# [ ["abcdef", "gh"], ["abcgh", "def"], ["abc", "defgh"], ["ijklm", "nop"], ["ijknop", "lm"], ["ijk", "lmnop"] ]
# TODO: Look into representing a substring as a dictionary or collections.counter instead of sorting
def concatenate_strings(list_of_substrings):
    output = set()
    for substring in list_of_substrings:
        n = len(substring)
        for i in range(0,n):
            for j in range (i+1, n):
                new_list = substring[0:i] + [substring[i] + substring[j]] + substring[i+1:j] + substring[j+1:n]
                output.add(tuple(sorted(new_list)))
    return [list(x) for x in output]


# TODO: move import/export functions to a seperate file maybe?
# import the raw list of english words to a dictionary
def import_raw_to_dict(file_name):
    word_dict={}
    with open(file_name) as file:
        for line in file:
            value = line.strip().lower()
            key = word_to_number(value)
            word_dict[key]=word_dict.get(key, [])+[value]
    return word_dict

# import processed list of english words to a dictionary
def import_dict_to_dict(file_name):
    word_dict={}
    with open(file_name) as file:
        for line in file:
            [skey,values] = line.strip().split(":")
            key= int(skey)
            value = [word for word in values.split(",")]
            word_dict[key] = value
    return word_dict

# export the dictionary into a processed list of words
def export_dict(file_name, dictionary):
    with open(file_name, "a") as file:
        for key in dictionary:
            string = str(key)+":"
            for word in dictionary[key]:
                string = string + word + ","
            string = string.strip(",") + "\n"
            file.write(string)

def time_function(fun, *args, amount):
    start = time.perf_counter()
    for i in range(amount):
        fun(*args)
    end = time.perf_counter()
    return end-start


# This is all basically manually testing xd
if __name__ == '__main__':
    time1 = time_function(import_raw_to_dict, "words_alpha.txt", amount=100)
    time2 = time_function(import_raw_to_dict, "google_10000_english.txt", amount=100)
    print("The time it took to run raw to dict 100 times is", time1, "and", time2)
    time3 = time_function(import_dict_to_dict, "words_alpha_dict.txt", amount=100)
    time4 = time_function(import_dict_to_dict, "google_10000_english_dict.txt", amount=100)
    print("The time it took to run dict to dict 100 times is", time3, "and", time4)

    print("Importing dictionary, please wait...")
    # TODO: Check if importing raw or importing dict is faster
    # Dictionary format: {number: [list of words]}
    # where each word in the list of words satisfies word_to_number(word) = number
    try:
        word_dict = import_dict_to_dict(processed_input)
    except:
        word_dict = import_raw_to_dict(raw_input)
        export_dict(processed_input, word_dict)
    print("Finished importing!")

    while True:
        string = input("Enter a string to descramble: \n")
        try:
            key = word_to_number(string)
        except:
            print ("Please make sure to only use letters a-z in your string!", end = " ")
            continue
        try:
            values = word_dict[key]
            print("Here is a list of possible words your string could be:", values)
        except:
            print("No words were found!")
        
        # TODO: Test the new sentence anagram code
        print("Searching sentences:")
        n = len(string)
        list_of_substrings = [list(string)]
        lists_of_sentences = []
        while(n>1):
            lists_of_sentences += [search_strings(substring, word_dict) for substring in list_of_substrings if search_strings(substring, word_dict)]
            list_of_substrings = concatenate_strings(list_of_substrings)
            n -= 1
        print("Sentences found:")
        for sentence in lists_of_sentences:
            print(sentence)