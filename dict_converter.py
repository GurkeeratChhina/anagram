import time

primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
raw_input = 'mit_10000.txt'

# Encodes letters as prime numbers
# Example usage: letter_to_prime("e") = 11
def letter_to_prime(letter):
    index = ord(letter) - ord('a')
    return primes[index]

# Each word gets assigned a number such that two words have the same number iff they have all the same letters
# Example usage: word_to_number("hello") = 19*11*37*37*47 = 13447687
def word_to_number(word):
    product = 1
    for letter in word:
        product = product * letter_to_prime(letter)
    return product

# Given a list of strings, find a list of possible sentences from anagramming each string
# Example usage: search_strings(["a", "aber", "aet", "em"]) = 
# [["a"], ["bear", "bare"], ["ate", "eta", "tea"], ["me"]]
def search_strings(list_of_strings, english_dict):
    list_of_sentences = []
    for string in list_of_strings:
        key = word_to_number(string)
        try:
            values = english_dict[key]
            list_of_sentences.append(values)
        except:
            return []
    return list_of_sentences

def search_ints(list_of_ints, english_dict):
    list_of_sentences = []
    for key in list_of_ints:
        try:
            values = english_dict[key]
            list_of_sentences.append(values)
        except:
            return []
    return list_of_sentences

# A substring is a list of ints, named such because the list of ints represent substrings of a given string
# Given a list of substrings, (recursively) generate a new list of substrings where each new substring has length 1 less than the input
# The new substrings are generated by concatenating each pair of words in a given substring
# The output should have no duplicate substrings, where two substrings with a different order are considered duplicates 
# eg ["a", "b"] and ["b", "a"] are considered duplicate substrings
# Example usage: concatenate_strings([["abc", "def", "gh"], ["ijk", "lm", "nop"]]) =
# [ ["abcdef", "gh"], ["abcgh", "def"], ["abc", "defgh"], ["ijklm", "nop"], ["ijknop", "lm"], ["ijk", "lmnop"] ]
# TODO: Look into representing a substring as a dictionary or collections.counter instead of sorting
def concatenate_strings(list_of_substrings):
    output = set()
    for substring in list_of_substrings:
        n = len(substring)
        for i in range(0,n):
            for j in range (i+1, n):
                new_list = substring[0:i] + [substring[i]*substring[j]] + substring[i+1:j] + substring[j+1:n]
                output.add(tuple(sorted(new_list)))
    return [list(x) for x in output]

# import the raw list of english words to a dictionary
# Dictionary format: {number: [list of words]}
# where each word in the list of words satisfies word_to_number(word) = number
def import_raw_to_dict(file_name):
    word_dict={}
    with open(file_name) as file:
        for line in file:
            value = line.strip().lower()
            key = word_to_number(value)
            word_dict[key]=word_dict.get(key, [])+[value]
    return word_dict

def time_function(fun, *args, amount):
    start = time.perf_counter()
    for i in range(amount):
        fun(*args)
    end = time.perf_counter()
    return end-start


# This is all basically manually testing xd
if __name__ == '__main__':
    print("Importing dictionary, please wait...")
    word_dict = import_raw_to_dict(raw_input)
    print("Finished importing!")

    while True:
        string = input("Enter a string to descramble: \n")
        try:
            key = word_to_number(string)
        except:
            print ("Please make sure to only use letters a-z in your string!", end = " ")
            continue
        try:
            values = word_dict[key]
            print("Here is a list of possible words your string could be:", values)
        except:
            print("No words were found!")
        
        # TODO: Test the new sentence anagram code
        print("Searching sentences:")
        start = time.perf_counter()
        n = len(string)
        list_of_substrings = [[letter_to_prime(letter) for letter in string]]
        lists_of_sentences = []
        while(n>1):
            lists_of_sentences += [search_ints(substring, word_dict) for substring in list_of_substrings if search_ints(substring, word_dict)]
            list_of_substrings = concatenate_strings(list_of_substrings)
            n -= 1
        end = time.perf_counter()
        print("Sentences found:")
        for sentence in lists_of_sentences:
            print(sentence)
        print("Time elapsed:", end-start)